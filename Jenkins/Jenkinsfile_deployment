pipeline {
    agent any

    parameters {
        choice(
            name: 'ACTION',
            choices: ['create', 'destroy'],
            description: 'Choose whether to create or destroy Kubernetes resources.'
        )
    }

    stages {
        stage('Git Checkout') {
            steps {
                script {
                    echo "üì• Checking out source code..."
                    checkout scm
                }
            }
        }

        stage('Load Environment Variables') {
            steps {
                script {
                    echo "üì¶ Copying Jenkins.env from 'tools' pipeline..."
                    copyArtifacts projectName: 'tools', filter: 'Jenkins.env', target: './', optional: false

                    if (!fileExists('Jenkins.env')) {
                        error "‚ùå Jenkins.env file not found. Aborting build."
                    }

                    echo "üìñ Loading environment variables using env_loader.groovy..."
                    def envLoader = load 'groovy/env_loader.groovy'
                    def envMap = envLoader.loadEnvVars('Jenkins.env')

                    envMap.each { k, v ->
                        env."${k}" = v
                        echo "‚úÖ Loaded: ${k}=${v}"
                    }

                    echo "üåç All variables successfully loaded into the environment"
                }
            }
        }

        stage('Create Docker Images') {
            steps {
                script {
                    def dockerBuild = load 'groovy/docker_build.groovy'
                        dockerBuild.createDockerBuild()
                }
            }
        }
        stage('Trivy Image Scan') {
            steps {
                script {
                    def trivyScan = load 'groovy/trivy_image.groovy'
                    trivyScan.scanAndArchiveImages()
                }
            }
        }
        stage('Docker Push') {
            steps {
                script {
                    def dockerPush = load 'groovy/docker_push.groovy'
                    dockerPush.pushImages()
                }
            }
        }

    }
}


//         stage('Docker Push') {
//             steps {
//                 script {
//                     echo "üöÄ Pushing Docker image to registry..."
//                     sh "docker push ${DOCKER_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}"
//                 }
//             }
//         }

//         stage('Image Scanning') {
//             steps {
//                 script {
//                     echo "üîç Scanning Docker image for vulnerabilities..."
//                     sh "trivy image --exit-code 1 --no-progress ${DOCKER_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}"
//                 }
//             }
//         }

//         stage('Kubernetes Deployment') {
//             steps {
//                 script {
//                     echo "üö¢ Deploying to Kubernetes..."
//                     if (params.ACTION == 'create') {
//                         sh "kubectl apply -f k8s/deployment.yaml --namespace=${K8S_NAMESPACE}"
//                     } else {
//                         sh "kubectl delete -f k8s/deployment.yaml --namespace=${K8S_NAMESPACE}"
//                     }
//                 }
//             }
//         }
//     }

//     post {
//         success {
//             echo "‚úÖ Pipeline completed successfully."
//         }
//         failure {
//             echo "‚ùå Pipeline failed. Please check the logs."
//         }
//         always {
//             echo "üì¶ Final environment: ACTION=${params.ACTION}, CLOUD_PROVIDER=${env.CLOUD_PROVIDER}"
//         }
//     }
// }
